import java.io.PrintWriter
import kotlin.system.exitProcess

fun main(args: Array<String>) {
    if (args.size != 1) {
        println("Usage: generate_ast <output directory>")
        exitProcess(1)
    }
    val outputDir = args[0]

    AstGenerator.defineAst(
        outputDir,
        "Expression",
        listOf(
            "Assign     : Token name, Expression value",
            "Binary     : Expression left, Token operator, Expression right",
            "Grouping   : Expression expr",
            "Literal    : Any? value",
            "Unary      : Token operator, Expression right",
            "Variable   : Token name"
        )
    )

    AstGenerator.defineAst(
        outputDir,
        "Statement",
        listOf(
            "Block       : List<Statement> statements",
            "Expr        : Expression expr",
            "Print       : Expression expr",
            "Variable    : Token name, Expression? value"
        )
    )
}

/**
 * Implements functions to quickly generate our Expression.kt file, which describes all the possible
 * grammar classes.
 */
object AstGenerator {

    /** Defines Expression abstract class and its "children" types. */
    fun defineAst(outputDir: String, baseName: String, types: List<String>) {
        val writer = PrintWriter("$outputDir/$baseName.kt", "UTF-8")

        writer.println("/** This file is autogenerated using [AstGenerator.defineAst]. */")
        writer.println("abstract class $baseName {")
        writer.println()
        writer.println("\tabstract fun <T> accept(visitor: Visitor<T>): T")
        writer.println()
        defineVisitor(writer, baseName, types)
        writer.println()

        types.forEach { type ->
            val className = type.split(":")[0].trim()
            val fields = type.split(":")[1].trim()
            defineType(writer, baseName, className, fields)
        }

        writer.println("}")
        writer.close()
    }

    /** Defines Visitor<T> interface. */
    private fun defineVisitor(writer: PrintWriter, baseName: String, types: List<String>) {
        writer.println("\tinterface Visitor<T> {")
        types.forEach { type ->
            val typeName = type.split(":")[0].trim()
            writer.println("\t\tfun visit$typeName$baseName(${baseName.lowercase()}: $typeName): T")
        }
        writer.println("\t}")
    }

    /** Defines type data class. */
    private fun defineType(
        writer: PrintWriter,
        baseName: String,
        className: String,
        fieldList: String
    ) {
        writer.print("\tdata class $className(")

        val fields = fieldList.split(", ")
        fields.forEachIndexed { index, it ->
            val type = it.split(" ")[0]
            val name = it.split(" ")[1]
            if (index == fields.size - 1) writer.print("val $name: $type") // last
            else writer.print("val $name: $type, ")
        }

        writer.println("): $baseName() {")
        writer.println(
            "\t\toverride fun <T> accept(visitor: Visitor<T>) = visitor.visit$className$baseName(this)"
        )
        writer.println("\t}")
        writer.println()
    }
}
